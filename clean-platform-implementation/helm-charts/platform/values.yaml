global:
  environment: dev
  domain: platform.example.com
  imageRegistry: 123456789012.dkr.ecr.us-east-1.amazonaws.com
  imagePullSecrets: []
  storageClass: gp3
  monitoring:
    enabled: true
    namespace: prometheus
  ingress:
    enabled: true
    className: nginx
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt-prod

# Sub-chart configurations
api-gateway:
  enabled: true
  replicaCount: 2
  image:
    repository: platform/api-gateway
    tag: latest
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 80
    targetPort: 8080
  ingress:
    enabled: true
    host: api.platform.example.com
    tls:
      enabled: true
  resources:
    requests:
      memory: "256Mi"
      cpu: "250m"
    limits:
      memory: "512Mi"
      cpu: "500m"
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
  nodeSelector: {}
  tolerations: []
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app.kubernetes.io/name
                  operator: In
                  values:
                    - api-gateway
            topologyKey: kubernetes.io/hostname

data-collector:
  enabled: true
  replicaCount: 3
  image:
    repository: platform/data-collector
    tag: latest
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 80
    targetPort: 8080
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "1Gi"
      cpu: "1000m"
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 20
    targetCPUUtilizationPercentage: 60
    targetMemoryUtilizationPercentage: 70
  env:
    - name: WORKER_PROCESSES
      value: "4"
    - name: DATABASE_POOL_SIZE
      value: "20"
  persistence:
    enabled: true
    size: 10Gi
    mountPath: /data
  redis:
    host: redis-master.redis.svc.cluster.local
    port: 6379
  postgresql:
    host: postgresql.database.svc.cluster.local
    port: 5432
    database: platform

data-processor:
  enabled: true
  replicaCount: 3
  image:
    repository: platform/data-processor
    tag: latest
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 80
    targetPort: 8080
  resources:
    requests:
      memory: "1Gi"
      cpu: "1000m"
    limits:
      memory: "2Gi"
      cpu: "2000m"
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 15
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
  celery:
    workers: 4
    concurrency: 10
    queues: "default,priority,batch"
  env:
    - name: CELERY_RESULT_BACKEND
      value: "redis://redis-master.redis.svc.cluster.local:6379/1"
    - name: CELERY_BROKER_URL
      value: "redis://redis-master.redis.svc.cluster.local:6379/0"

# Common configurations
commonLabels:
  team: platform
  managed-by: helm

commonAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/metrics"

serviceAccount:
  create: true
  annotations: {}
  name: ""

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - ALL

networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress

podDisruptionBudget:
  enabled: true
  minAvailable: 1

monitoring:
  serviceMonitor:
    enabled: true
    interval: 30s
    scrapeTimeout: 10s
  prometheusRule:
    enabled: true
    alerts:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }} errors per second"

backup:
  enabled: true
  schedule: "0 2 * * *"
  retention: 7